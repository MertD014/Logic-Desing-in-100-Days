# Logic-Desing-in-100-Days

This gives you a 100 days of challenges, ranging from basic circuits to complex systems like CPUs and memory controllers. Each task is rated on a difficulty scale from 1 to 5 stars. From fundamentals to advanced circuits. Have fun!

# 100 Days of Logic Circuit Design with Logisim

Welcome to the **100 Days of Logic Circuit Design** challenge! This repository contains daily tasks to help you master logic circuit design. Each day focuses on a specific logic circuit design, starting from basic gates and progressing to more complex digital systems.

## How It Works

- Every day, you'll complete one challenge, starting from simple circuits and building up to advanced designs.
- Each challenge has a difficulty rating: `★` for easy, `★★` for intermediate, and up to `★★★★★` for advanced.
- Save each circuit design as a `.circ` file in the respective day folder with your github name. (e.g., `Day01/John`, `Day02/Jane`).
- You can upload additional files like a .pdf files that explains your circuit or a screenshot for quick preview of your circuit.
- You can contact me via Discord for any of your questions or discussion. Or you can join my server for all that and more!
  **[https://discord.gg/99krPw52mK]**

## Contributions

Feel free to contribute by:

- Suggesting new challenges.
- Improving existing designs.
- Submitting pull requests with additional circuit solutions.

## Daily Challenges

1.  Days 00-09: Basic Logic Gates
2.  Days 10-19: Combinational Circuits
3.  Days 20-29: Adders and Subtractors
4.  Days 30-39: Multiplexers, Decoders, and Encoders
5.  Days 40-49: Flip-Flops and Latches
6.  Days 50-59: Counters and Registers
7.  Days 60-69: Arithmetic Circuits
8.  Days 70-79: Memory and Storage
9.  Days 80-89: Sequential Circuits and FSMs
10. Days 90-99: Final Advanced Projects

### Days 00-09: Basic Logic Gates

1. **Day 00**: Create a single AND gate with two inputs. **(★☆☆☆☆ Complexity: Low)**
2. **Day 01**: Design a circuit that outputs true if at least one of the two inputs is true using an OR gate. **(★☆☆☆☆ Complexity: Low)**
3. **Day 02**: Build a NOT gate that outputs the opposite of the input. **(★☆☆☆☆ Complexity: Low)**
4. **Day 03**: Combine two NOT gates in series. Observe and explain the output. **(★☆☆☆☆ Complexity: Low)**
5. **Day 04**: Design a circuit with two AND gates and an OR gate to create a basic combination of logic. **(★☆☆☆☆ Complexity: Low)**
6. **Day 05**: Design a circuit with three inputs that outputs true if exactly two inputs are true. **(★★☆☆☆ Complexity: Medium)**
7. **Day 06**: Create a 3-input XOR circuit. **(★★☆☆☆ Complexity: Medium)**
8. **Day 07**: Design a circuit with 4 inputs that outputs true only if all inputs are true using AND gates. **(★☆☆☆☆ Complexity: Low)**
9. **Day 08**: Design a circuit with 4 inputs that outputs true if the number of true inputs is odd (parity checker). **(★★☆☆☆ Complexity: Medium)**
10. **Day 09**: Create a circuit that takes a 4-bit binary number as input and outputs true if the number is divisible by 5. **(★★★☆☆ Complexity: High)**

### Days 10-19: Combinational Circuits

11. **Day 10**: Design a circuit that outputs the majority value of three inputs. **(★★☆☆☆ Complexity: Medium)**
12. **Day 11**: Create a 2-to-1 multiplexer using AND, OR, and NOT gates. **(★★☆☆☆ Complexity: Medium)**
13. **Day 12**: Build a 4-to-1 multiplexer using 2-to-1 multiplexers. **(★★★☆☆ Complexity: Medium-High)**
14. **Day 13**: Design a 1-bit comparator circuit that outputs true if two inputs are equal. **(★☆☆☆☆ Complexity: Low)**
15. **Day 14**: Extend the 1-bit comparator to a 4-bit comparator. **(★★☆☆☆ Complexity: Medium)**
16. **Day 15**: Create a circuit that identifies if a 3-bit binary input is greater than or equal to 4. **(★★☆☆☆ Complexity: Medium)**
17. **Day 16**: Design a circuit that outputs true if the 3-bit binary input is a prime number. **(★★★☆☆ Complexity: High)**
18. **Day 17**: Build a decoder circuit that converts a 3-bit binary input to one of eight outputs. **(★★☆☆☆ Complexity: Medium)**
19. **Day 18**: Create an encoder that takes one of eight inputs and provides a 3-bit binary output. **(★★☆☆☆ Complexity: Medium)**
20. **Day 19**: Design a priority encoder that outputs the position of the highest active input out of four. **(★★★☆☆ Complexity: High)**

### Days 20-29: Adders and Subtractors

21. **Day 20**: Design a half adder that adds two 1-bit numbers. **(★☆☆☆☆ Complexity: Low)**
22. **Day 21**: Build a full adder that adds three 1-bit numbers. **(★★☆☆☆ Complexity: Medium)**
23. **Day 22**: Construct a 4-bit ripple-carry adder using full adders. **(★★★☆☆ Complexity: High)**
24. **Day 23**: Create a 4-bit adder/subtractor circuit. **(★★★☆☆ Complexity: High)**
25. **Day 24**: Design a 2’s complement circuit for a 4-bit number. **(★★☆☆☆ Complexity: Medium)**
26. **Day 25**: Create a 4-bit binary subtractor using 2's complement and a ripple-carry adder. **(★★★☆☆ Complexity: High)**
27. **Day 26**: Design a BCD (Binary Coded Decimal) adder circuit. **(★★★☆☆ Complexity: High)**
28. **Day 27**: Build a 4-bit binary multiplier circuit. **(★★★★☆ Complexity: Very High)**
29. **Day 28**: Construct a 4-bit binary divider circuit. **(★★★★☆ Complexity: Very High)**
30. **Day 29**: Create an 8-bit ripple-carry adder. **(★★★★☆ Complexity: Very High)**

### Days 30-39: Multiplexers, Decoders, and Encoders

31. **Day 30**: Design a 3-to-8 line decoder. **(★★☆☆☆ Complexity: Medium)**
32. **Day 31**: Build a 4-to-16 line decoder using 3-to-8 decoders. **(★★★☆☆ Complexity: High)**
33. **Day 32**: Create a 2-to-4 line demultiplexer. **(★★☆☆☆ Complexity: Medium)**
34. **Day 33**: Build a 4-to-1 multiplexer circuit from scratch. **(★★☆☆☆ Complexity: Medium)**
35. **Day 34**: Design an 8-to-1 multiplexer using 4-to-1 multiplexers. **(★★★☆☆ Complexity: High)**
36. **Day 35**: Create a priority encoder for eight inputs. **(★★★☆☆ Complexity: High)**
37. **Day 36**: Build a circuit that counts the number of 1's in a 4-bit binary input (population counter). **(★★★☆☆ Complexity: High)**
38. **Day 37**: Design a circuit to check for parity in an 8-bit input. **(★★★☆☆ Complexity: High)**
39. **Day 38**: Create a 4-bit Johnson counter. **(★★☆☆☆ Complexity: Medium)**
40. **Day 39**: Design a 4-bit ring counter. **(★★☆☆☆ Complexity: Medium)**

### Days 40-49: Flip-Flops and Latches

41. **Day 40**: Create a basic SR (Set-Reset) latch circuit using NAND gates. **(★☆☆☆☆ Complexity: Low)**
42. **Day 41**: Build a gated SR latch circuit. **(★★☆☆☆ Complexity: Medium)**
43. **Day 42**: Design a D (Data) flip-flop. **(★★☆☆☆ Complexity: Medium)**
44. **Day 43**: Create a JK flip-flop circuit. **(★★★☆☆ Complexity: High)**
45. **Day 44**: Build a T (Toggle) flip-flop using a JK flip-flop. **(★★☆☆☆ Complexity: Medium)**
46. **Day 45**: Design a master-slave JK flip-flop. **(★★★☆☆ Complexity: High)**
47. **Day 46**: Create a 4-bit register using D flip-flops. **(★★★☆☆ Complexity: High)**
48. **Day 47**: Build a shift register that shifts left on each clock pulse. **(★★☆☆☆ Complexity: Medium)**
49. **Day 48**: Design a shift register that shifts right on each clock pulse. **(★★☆☆☆ Complexity: Medium)**
50. **Day 49**: Construct a parallel-in, serial-out shift register. **(★★★☆☆ Complexity: High)**

### Days 50-59: Counters and Registers

51. **Day 50**: Create a 3-bit binary up-counter. **(★★☆☆☆ Complexity: Medium)**
52. **Day 51**: Build a 3-bit binary down-counter. **(★★☆☆☆ Complexity: Medium)**
53. **Day 52**: Design a 4-bit asynchronous counter. **(★★★☆☆ Complexity: High)**
54. **Day 53**: Construct a 4-bit synchronous counter. **(★★★☆☆ Complexity: High)**
55. **Day 54**: Create a ring counter with 4 bits. **(★★☆☆☆ Complexity: Medium)**
56. **Day 55**: Design a Johnson counter with 4 bits. **(★★☆☆☆ Complexity: Medium)**
57. **Day 56**: Build a 4-bit BCD counter. **(★★★☆☆ Complexity: High)**
58. **Day 57**: Construct a decade counter (0-9) using flip-flops. **(★★★☆☆ Complexity: High)**
59. **Day 58**: Design a modulo-6 counter. **(★★★☆☆ Complexity: High)**
60. **Day 59**: Create a programmable 4-bit counter. **(★★★★☆ Complexity: Very High)**

### Days 60-69: Arithmetic Circuits

61. **Day 60**: Design a 4-bit binary multiplier. **(★★★☆☆ Complexity: High)**
62. **Day 61**: Build a 4-bit binary divider. **(★★★★☆ Complexity: Very High)**
63. **Day 62**: Create a 4-bit square root calculator circuit. **(★★★★☆ Complexity: Very High)**
64. **Day 63**: Construct an 8-bit accumulator circuit. **(★★★★☆ Complexity: Very High)**
65. **Day 64**: Design a 4-bit barrel shifter. **(★★★☆☆ Complexity: High)**
66. **Day 65**: Build a multiplier-accumulator (MAC) unit. **(★★★★☆ Complexity: Very High)**
67. **Day 66**: Design a circuit that computes 2’s complement multiplication. **(★★★★☆ Complexity: Very High)**
68. **Day 67**: Create a 4-bit ALU (Arithmetic Logic Unit). **(★★★★☆ Complexity: Very High)**
69. **Day 68**: Extend the ALU to support 8-bit operations. **(★★★★★ Complexity: Expert)**
70. **Day 69**: Add overflow detection to the 8-bit ALU. **(★★★★★ Complexity: Expert)**

### Days 70-79: Memory and Storage

71. **Day 70**: Build a simple 2x2 SRAM cell array. **(★★★☆☆ Complexity: High)**
72. **Day 71**: Create a 4x4 SRAM cell array with read/write controls. **(★★★★☆ Complexity: Very High)**
73. **Day 72**: Design a 4x4 DRAM cell array. **(★★★★☆ Complexity: Very High)**
74. **Day 73**: Construct a 1-bit D flip-flop memory cell. **(★★★☆☆ Complexity: High)**
75. **Day 74**: Build a 4x1 memory cell array with a decoder. **(★★★★☆ Complexity: Very High)**
76. **Day 75**: Create a 4x4 ROM array with predefined data. **(★★★★☆ Complexity: Very High)**
77. **Day 76**: Design an EEPROM simulation with manual write capabilities. **(★★★★★ Complexity: Expert)**
78. **Day 77**: Build a 4x4 cache memory with a simple replacement policy. **(★★★★★ Complexity: Expert)**
79. **Day 78**: Create a FIFO (First-In-First-Out) buffer circuit. **(★★★★☆ Complexity: Very High)**
80. **Day 79**: Design a LIFO (Last-In-First-Out) stack buffer circuit. **(★★★★☆ Complexity: Very High)**

### Days 80-89: Sequential Circuits and FSMs

81. **Day 80**: Design a sequence detector for “101” pattern. **(★★★☆☆ Complexity: High)**
82. **Day 81**: Extend the sequence detector to recognize “1101”. **(★★★★☆ Complexity: Very High)**
83. **Day 82**: Create a finite state machine to control a vending machine. **(★★★★☆ Complexity: Very High)**
84. **Day 83**: Build a simple traffic light controller using FSM. **(★★★☆☆ Complexity: High)**
85. **Day 84**: Design a 3-state elevator controller FSM. **(★★★★☆ Complexity: Very High)**
86. **Day 85**: Construct a pedestrian crosswalk signal FSM. **(★★★☆☆ Complexity: High)**
87. **Day 86**: Create an FSM that counts up to a random number. **(★★★★☆ Complexity: Very High)**
88. **Day 87**: Build a 4-bit sequence generator using FSM. **(★★★★☆ Complexity: Very High)**
89. **Day 88**: Design a digital lock FSM (input PIN code). **(★★★★☆ Complexity: Very High)**
90. **Day 89**: Create a stopwatch using FSM and counters. **(★★★★★ Complexity: Expert)**

### Days 90-99: Final Advanced Projects

91. **Day 90**: Design a simple 4-function calculator (addition, subtraction, multiplication, division). **(★★★★★ Complexity: Expert)**
92. **Day 91**: Build a binary clock with hour, minute, and second displays. **(★★★★☆ Complexity: Very High)**
93. **Day 92**: Construct an 8-bit data encryption circuit. **(★★★★★ Complexity: Expert)**
94. **Day 93**: Design a 4-bit programmable timer. **(★★★★☆ Complexity: Very High)**
95. **Day 94**: Create a UART (Universal Asynchronous Receiver-Transmitter) circuit. **(★★★★★ Complexity: Expert)**
96. **Day 95**: Implement a digital thermometer simulation. **(★★★★☆ Complexity: Very High)**
97. **Day 96**: Design a 4-bit mini CPU (fetch, decode, execute). **(★★★★★ Complexity: Expert)**
98. **Day 97**: Build a programmable shift-and-add multiplier. **(★★★★★ Complexity: Expert)**
99. **Day 98**: Create a binary digital to analog converter (DAC) circuit. **(★★★★☆ Complexity: Very High)**
100.  **Day 99**: Final Project: Build a mini-processor with an ALU, control unit, and memory. **(★★★★★ Complexity: Expert)**

## Challenge Structure

### Week 1: Basic Gates and Circuits (Easy)

1. **Day 1**: Create a basic AND, OR, and NOT gate circuit. (★☆☆☆☆)
2. **Day 2**: Design a 2-input XOR gate using AND, OR, and NOT gates. (★☆☆☆☆)
3. **Day 3**: Build a 3-input AND gate. (★☆☆☆☆)
4. **Day 4**: Create a 2-to-1 multiplexer. (★☆☆☆☆)
5. **Day 5**: Design a 1-bit half-adder circuit. (★☆☆☆☆)
6. **Day 6**: Design a 1-bit full-adder circuit. (★½☆☆☆)
7. **Day 7**: Create a 4-input NAND gate. (★½☆☆☆)

### Week 2: Intermediate Combinational Circuits

8. **Day 8**: Build a 4-to-1 multiplexer. (★★☆☆☆)
9. **Day 9**: Design a 2-bit comparator circuit. (★★☆☆☆)
10. **Day 10**: Build a 4-bit binary adder using full adders. (★★☆☆☆)
11. **Day 11**: Create a 4-bit subtractor circuit. (★★☆☆☆)
12. **Day 12**: Design a 4-bit ALU that can add and subtract. (★★½☆☆)
13. **Day 13**: Build a 4-bit even parity generator. (★★☆☆☆)
14. **Day 14**: Create a 3-to-8 decoder circuit. (★★½☆☆)

### Week 3: Sequential Circuits (Intermediate to Advanced)

15. **Day 15**: Design a basic SR flip-flop. (★★½☆☆)
16. **Day 16**: Build a JK flip-flop. (★★½☆☆)
17. **Day 17**: Create a D flip-flop. (★★½☆☆)
18. **Day 18**: Design a T flip-flop. (★★½☆☆)
19. **Day 19**: Implement a 4-bit shift register. (★★½☆☆)
20. **Day 20**: Build a 3-bit binary counter. (★★½☆☆)
21. **Day 21**: Create a synchronous 4-bit counter. (★★★☆☆)

### Week 4: Complex Sequential Circuits

22. **Day 22**: Design a 4-bit ALU that can add, subtract, AND, OR, and XOR. (★★★☆☆)
23. **Day 23**: Build a 4-bit ripple carry adder. (★★★☆☆)
24. **Day 24**: Create a 4-bit asynchronous counter. (★★★☆☆)
25. **Day 25**: Design a 7-segment display driver for hexadecimal values. (★★★☆☆)
26. **Day 26**: Build a 16-bit adder using 4-bit blocks. (★★★½☆)
27. **Day 27**: Create a 4-bit synchronous up/down counter. (★★★½☆)
28. **Day 28**: Design a 4-bit binary multiplier. (★★★½☆)
29. **Day 29**: Build a simple 8-bit CPU with basic instructions (ADD, SUB, MOV). (★★★★☆)
30. **Day 30**: Design a memory circuit with read/write functionality. (★★★★☆)

---

### Advanced Circuits and Systems

31. **Day 31**: Build an 8-to-1 multiplexer. (★★½☆☆)
32. **Day 32**: Design a 4-bit priority encoder. (★★½☆☆)
33. **Day 33**: Create an 8-bit shift register. (★★½☆☆)
34. **Day 34**: Design an 8-bit ALU with AND, OR, ADD, SUB operations. (★★★☆☆)
35. **Day 35**: Build an 8-bit comparator circuit. (★★★☆☆)
36. **Day 36**: Design a 16-bit binary adder using ripple carry adders. (★★★½☆)
37. **Day 37**: Create a 32-bit ripple carry adder. (★★★★☆)
38. **Day 38**: Build a 4-bit Booth multiplier. (★★★★☆)
39. **Day 39**: Design a 16-bit binary multiplier using add-and-shift algorithm. (★★★★☆)
40. **Day 40**: Build an 8-bit carry-lookahead adder. (★★★★☆)

---

### Sequential Logic Circuits (Advanced)

41. **Day 41**: Design a 4-bit synchronous up/down counter with load. (★★★½☆)
42. **Day 42**: Create a Johnson counter. (★★★☆☆)
43. **Day 43**: Implement a Ring counter. (★★★☆☆)
44. **Day 44**: Build a 4-bit binary Gray code counter. (★★★½☆)
45. **Day 45**: Design an 8-bit shift register with parallel load. (★★★½☆)
46. **Day 46**: Create a synchronous 4-bit decade counter. (★★★☆☆)
47. **Day 47**: Build a 16-bit binary counter with carry out. (★★★½☆)
48. **Day 48**: Design a 4-bit BCD adder. (★★★½☆)
49. **Day 49**: Create a 4-bit Fibonacci LFSR (Linear Feedback Shift Register). (★★★★☆)
50. **Day 50**: Build a 4-bit pseudo-random number generator using LFSR. (★★★★☆)

---

### Memory and Storage Design (Advanced)

51. **Day 51**: Design a 1-bit SRAM cell. (★★★☆☆)
52. **Day 52**: Build a 4x4 memory array using SRAM cells. (★★★☆☆)
53. **Day 53**: Create a 4-bit D flip-flop based register file. (★★★½☆)
54. **Day 54**: Design a 4x4 memory system with address decoder. (★★★½☆)
55. **Day 55**: Build an 8x8 memory system using D flip-flops. (★★★½☆)
56. **Day 56**: Create a simple 8-bit RAM module with read/write capability. (★★★★☆)
57. **Day 57**: Design a 16x16 memory system with separate data and address buses. (★★★★☆)
58. **Day 58**: Implement a 32-bit memory with multiplexed address/data buses. (★★★★☆)
59. **Day 59**: Build a 64x8 memory with simple read/write control logic. (★★★★½)
60. **Day 60**: Design a memory-mapped I/O system for data storage. (★★★★½)

---

### Complex CPU Design and ALU Enhancements

61. **Day 61**: Create a 4-bit single-cycle CPU with basic arithmetic instructions. (★★★★½)
62. **Day 62**: Design a control unit for a simple 8-bit processor. (★★★★½)
63. **Day 63**: Implement a 16-bit ALU with logical shift and rotate. (★★★★½)
64. **Day 64**: Build an 8-bit pipelined processor. (★★★★★)
65. **Day 65**: Design a 16-bit pipelined processor with forwarding. (★★★★★)
66. **Day 66**: Create an 8-bit ALU with logical shift, rotate, AND, OR, and XOR. (★★★★½)
67. **Day 67**: Design a 32-bit ALU with overflow detection. (★★★★½)
68. **Day 68**: Build a 16-bit multiplier with carry-save addition. (★★★★★)
69. **Day 69**: Design a 32-bit CPU with a basic instruction set. (★★★★★)
70. **Day 70**: Implement a microprogrammed control unit for the 32-bit CPU. (★★★★★)

---

### Final Complex Systems and Enhancements

71. **Day 71**: Build a 64-bit binary adder using carry-lookahead logic. (★★★★½)
72. **Day 72**: Create a 64-bit ALU with add, subtract, AND, OR, and XOR operations. (★★★★½)
73. **Day 73**: Design a basic pipeline for a 16-bit processor. (★★★★½)
74. **Day 74**: Build a floating-point addition circuit. (★★★★★)
75. **Day 75**: Implement a floating-point multiplication circuit. (★★★★★)
76. **Day 76**: Create a 16-bit instruction fetch unit for a CPU. (★★★★★)
77. **Day 77**: Build a simple cache memory for a 32-bit processor. (★★★★★)
78. **Day 78**: Design a branch predictor circuit. (★★★★★)
79. **Day 79**: Create a floating-point ALU with add and multiply operations. (★★★★★)
80. **Day 80**: Implement a basic superscalar processor. (★★★★★)

---

### Final Complex Circuits and Systems

81. **Day 81**: Build a 32-bit memory-mapped I/O system. (★★★★½)
82. **Day 82**: Design a 32-bit synchronous CPU with branching. (★★★★★)
83. **Day 83**: Create a 64-bit ALU with overflow and carry detection. (★★★★★)
84. **Day 84**: Build a 64-bit floating-point ALU with add, subtract, and multiply operations. (★★★★★)
85. **Day 85**: Design a pipelined control unit for a 32-bit CPU. (★★★★★)
86. **Day 86**: Create a 32-bit out-of-order execution processor. (★★★★★)
87. **Day 87**: Build a simple 64-bit RISC-V CPU. (★★★★★)
88. **Day 88**: Design a 32-bit superscalar processor with branch prediction. (★★★★★)
89. **Day 89**: Create a floating-point division unit. (★★★★★)
90. **Day 90**: Implement a 32-bit multi-cycle CPU with pipelining. (★★★★★)

---

### Final Projects (Expert-Level)

91. **Day 91**: Design a 64-bit floating-point processor. (★★★★★)
92. **Day 92**: Build a 32-bit CPU with full instruction decoding and execution. (★★★★★)
93. **Day 93**: Create a 64-bit vector processor. (★★★★★)
94. **Day 94**: Design a basic GPU (Graphics Processing Unit) with pixel rendering. (★★★★★)
95. **Day 95**: Build a multi-core processor. (★★★★★)
96. **Day 96**: Design a 32-bit memory controller for cache and RAM. (★★★★★)
97. **Day 97**: Create a 64-bit multi-core CPU with pipelining. (★★★★★)
98. **Day 98**: Build a 128-bit ALU for high-performance computing. (★★★★★)
99. **Day 99**: Design a fully functional 32-bit RISC-V CPU. (★★★★★)

### Final Day

100. **Day 100**: Desing a
