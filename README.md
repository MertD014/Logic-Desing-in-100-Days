# Logic-Desing-in-100-Days

This gives you a 100 days of challenges, ranging from basic circuits to complex systems like CPUs and memory controllers. Each task is rated on a difficulty scale from 1 to 5 stars. From fundamentals to advanced circuits. Have fun!

# 100 Days of Logic Circuit Design with Logisim

Welcome to the **100 Days of Logic Circuit Design** challenge! This repository contains daily tasks to help you master logic circuit design. Each day focuses on a specific logic circuit design, starting from basic gates and progressing to more complex digital systems.

## How It Works

- Every day, you'll complete one challenge, starting from simple circuits and building up to advanced designs.
- Each challenge has a difficulty rating: `★` for easy, `★★` for intermediate, and up to `★★★★★` for advanced.
- Save each circuit design as a `.circ` file in the respective day folder with your github name. (e.g., `Day01/John`, `Day02/Jane`).
- You can upload additional files like a .pdf files that explains your circuit or a screenshot for quick preview of your circuit.
- You can contact me via Discord for any of your questions or discussion. Or you can join my server for all that and more!
  **[https://discord.gg/99krPw52mK]**

## Contributions

Feel free to contribute by:

- Suggesting new challenges.
- Improving existing designs.
- Submitting pull requests with additional circuit solutions.

## Daily Challenges

1.  Days 00-09: Basic Logic Gates
2.  Days 10-19: Combinational Circuits
3.  Days 20-29: Adders and Subtractors
4.  Days 30-39: Multiplexers, Decoders, and Encoders
5.  Days 40-49: Flip-Flops and Latches
6.  Days 50-59: Counters and Registers
7.  Days 60-69: Arithmetic Circuits
8.  Days 70-79: Memory and Storage
9.  Days 80-89: Sequential Circuits and FSMs
10. Days 90-99: Final Advanced Projects

### Days 00-09: Basic Logic Gates

1. **Day 00**: Create a single AND gate with two inputs. **(★☆☆☆☆ Complexity: Low)**
2. **Day 01**: Design a circuit that outputs true if at least one of the two inputs is true using an OR gate. **(★☆☆☆☆ Complexity: Low)**
3. **Day 02**: Build a NOT gate that outputs the opposite of the input. **(★☆☆☆☆ Complexity: Low)**
4. **Day 03**: Combine two NOT gates in series. Observe and explain the output. **(★☆☆☆☆ Complexity: Low)**
5. **Day 04**: Design a circuit with two AND gates and an OR gate to create a basic combination of logic. **(★☆☆☆☆ Complexity: Low)**
6. **Day 05**: Design a circuit with three inputs that outputs true if exactly two inputs are true. **(★★☆☆☆ Complexity: Medium)**
7. **Day 06**: Create a 3-input XOR circuit. **(★★☆☆☆ Complexity: Medium)**
8. **Day 07**: Design a circuit with 4 inputs that outputs true only if all inputs are true using AND gates. **(★☆☆☆☆ Complexity: Low)**
9. **Day 08**: Design a circuit with 4 inputs that outputs true if the number of true inputs is odd (parity checker). **(★★☆☆☆ Complexity: Medium)**
10. **Day 09**: Create a circuit that takes a 4-bit binary number as input and outputs true if the number is divisible by 5. **(★★★☆☆ Complexity: High)**

### Days 10-19: Combinational Circuits

11. **Day 10**: Design a circuit that outputs the majority value of three inputs. **(★★☆☆☆ Complexity: Medium)**
12. **Day 11**: Create a 2-to-1 multiplexer using AND, OR, and NOT gates. **(★★☆☆☆ Complexity: Medium)**
13. **Day 12**: Build a 4-to-1 multiplexer using 2-to-1 multiplexers. **(★★★☆☆ Complexity: Medium-High)**
14. **Day 13**: Design a 1-bit comparator circuit that outputs true if two inputs are equal. **(★☆☆☆☆ Complexity: Low)**
15. **Day 14**: Extend the 1-bit comparator to a 4-bit comparator. **(★★☆☆☆ Complexity: Medium)**
16. **Day 15**: Create a circuit that identifies if a 3-bit binary input is greater than or equal to 4. **(★★☆☆☆ Complexity: Medium)**
17. **Day 16**: Design a circuit that outputs true if the 3-bit binary input is a prime number. **(★★★☆☆ Complexity: High)**
18. **Day 17**: Build a decoder circuit that converts a 3-bit binary input to one of eight outputs. **(★★☆☆☆ Complexity: Medium)**
19. **Day 18**: Create an encoder that takes one of eight inputs and provides a 3-bit binary output. **(★★☆☆☆ Complexity: Medium)**
20. **Day 19**: Design a priority encoder that outputs the position of the highest active input out of four. **(★★★☆☆ Complexity: High)**

### Days 20-29: Adders and Subtractors

21. **Day 20**: Design a half adder that adds two 1-bit numbers. **(★☆☆☆☆ Complexity: Low)**
22. **Day 21**: Build a full adder that adds three 1-bit numbers. **(★★☆☆☆ Complexity: Medium)**
23. **Day 22**: Construct a 4-bit ripple-carry adder using full adders. **(★★★☆☆ Complexity: High)**
24. **Day 23**: Create a 4-bit adder/subtractor circuit. **(★★★☆☆ Complexity: High)**
25. **Day 24**: Design a 2’s complement circuit for a 4-bit number. **(★★☆☆☆ Complexity: Medium)**
26. **Day 25**: Create a 4-bit binary subtractor using 2's complement and a ripple-carry adder. **(★★★☆☆ Complexity: High)**
27. **Day 26**: Design a BCD (Binary Coded Decimal) adder circuit. **(★★★☆☆ Complexity: High)**
28. **Day 27**: Build a 4-bit binary multiplier circuit. **(★★★★☆ Complexity: Very High)**
29. **Day 28**: Construct a 4-bit binary divider circuit. **(★★★★☆ Complexity: Very High)**
30. **Day 29**: Create an 8-bit ripple-carry adder. **(★★★★☆ Complexity: Very High)**

### Days 30-39: Multiplexers, Decoders, and Encoders

31. **Day 30**: Design a 3-to-8 line decoder. **(★★☆☆☆ Complexity: Medium)**
32. **Day 31**: Build a 4-to-16 line decoder using 3-to-8 decoders. **(★★★☆☆ Complexity: High)**
33. **Day 32**: Create a 2-to-4 line demultiplexer. **(★★☆☆☆ Complexity: Medium)**
34. **Day 33**: Build a 4-to-1 multiplexer circuit from scratch. **(★★☆☆☆ Complexity: Medium)**
35. **Day 34**: Design an 8-to-1 multiplexer using 4-to-1 multiplexers. **(★★★☆☆ Complexity: High)**
36. **Day 35**: Create a priority encoder for eight inputs. **(★★★☆☆ Complexity: High)**
37. **Day 36**: Build a circuit that counts the number of 1's in a 4-bit binary input (population counter). **(★★★☆☆ Complexity: High)**
38. **Day 37**: Design a circuit to check for parity in an 8-bit input. **(★★★☆☆ Complexity: High)**
39. **Day 38**: Create a 4-bit Johnson counter. **(★★☆☆☆ Complexity: Medium)**
40. **Day 39**: Design a 4-bit ring counter. **(★★☆☆☆ Complexity: Medium)**

### Days 40-49: Flip-Flops and Latches

41. **Day 40**: Create a basic SR (Set-Reset) latch circuit using NAND gates. **(★☆☆☆☆ Complexity: Low)**
42. **Day 41**: Build a gated SR latch circuit. **(★★☆☆☆ Complexity: Medium)**
43. **Day 42**: Design a D (Data) flip-flop. **(★★☆☆☆ Complexity: Medium)**
44. **Day 43**: Create a JK flip-flop circuit. **(★★★☆☆ Complexity: High)**
45. **Day 44**: Build a T (Toggle) flip-flop using a JK flip-flop. **(★★☆☆☆ Complexity: Medium)**
46. **Day 45**: Design a master-slave JK flip-flop. **(★★★☆☆ Complexity: High)**
47. **Day 46**: Create a 4-bit register using D flip-flops. **(★★★☆☆ Complexity: High)**
48. **Day 47**: Build a shift register that shifts left on each clock pulse. **(★★☆☆☆ Complexity: Medium)**
49. **Day 48**: Design a shift register that shifts right on each clock pulse. **(★★☆☆☆ Complexity: Medium)**
50. **Day 49**: Construct a parallel-in, serial-out shift register. **(★★★☆☆ Complexity: High)**

### Days 50-59: Counters and Registers

51. **Day 50**: Create a 3-bit binary up-counter. **(★★☆☆☆ Complexity: Medium)**
52. **Day 51**: Build a 3-bit binary down-counter. **(★★☆☆☆ Complexity: Medium)**
53. **Day 52**: Design a 4-bit asynchronous counter. **(★★★☆☆ Complexity: High)**
54. **Day 53**: Construct a 4-bit synchronous counter. **(★★★☆☆ Complexity: High)**
55. **Day 54**: Create a ring counter with 4 bits. **(★★☆☆☆ Complexity: Medium)**
56. **Day 55**: Design a Johnson counter with 4 bits. **(★★☆☆☆ Complexity: Medium)**
57. **Day 56**: Build a 4-bit BCD counter. **(★★★☆☆ Complexity: High)**
58. **Day 57**: Construct a decade counter (0-9) using flip-flops. **(★★★☆☆ Complexity: High)**
59. **Day 58**: Design a modulo-6 counter. **(★★★☆☆ Complexity: High)**
60. **Day 59**: Create a programmable 4-bit counter. **(★★★★☆ Complexity: Very High)**

### Days 60-69: Arithmetic Circuits

61. **Day 60**: Design a 4-bit binary multiplier. **(★★★☆☆ Complexity: High)**
62. **Day 61**: Build a 4-bit binary divider. **(★★★★☆ Complexity: Very High)**
63. **Day 62**: Create a 4-bit square root calculator circuit. **(★★★★☆ Complexity: Very High)**
64. **Day 63**: Construct an 8-bit accumulator circuit. **(★★★★☆ Complexity: Very High)**
65. **Day 64**: Design a 4-bit barrel shifter. **(★★★☆☆ Complexity: High)**
66. **Day 65**: Build a multiplier-accumulator (MAC) unit. **(★★★★☆ Complexity: Very High)**
67. **Day 66**: Design a circuit that computes 2’s complement multiplication. **(★★★★☆ Complexity: Very High)**
68. **Day 67**: Create a 4-bit ALU (Arithmetic Logic Unit). **(★★★★☆ Complexity: Very High)**
69. **Day 68**: Extend the ALU to support 8-bit operations. **(★★★★★ Complexity: Expert)**
70. **Day 69**: Add overflow detection to the 8-bit ALU. **(★★★★★ Complexity: Expert)**

### Days 70-79: Memory and Storage

71. **Day 70**: Build a simple 2x2 SRAM cell array. **(★★★☆☆ Complexity: High)**
72. **Day 71**: Create a 4x4 SRAM cell array with read/write controls. **(★★★★☆ Complexity: Very High)**
73. **Day 72**: Design a 4x4 DRAM cell array. **(★★★★☆ Complexity: Very High)**
74. **Day 73**: Construct a 1-bit D flip-flop memory cell. **(★★★☆☆ Complexity: High)**
75. **Day 74**: Build a 4x1 memory cell array with a decoder. **(★★★★☆ Complexity: Very High)**
76. **Day 75**: Create a 4x4 ROM array with predefined data. **(★★★★☆ Complexity: Very High)**
77. **Day 76**: Design an EEPROM simulation with manual write capabilities. **(★★★★★ Complexity: Expert)**
78. **Day 77**: Build a 4x4 cache memory with a simple replacement policy. **(★★★★★ Complexity: Expert)**
79. **Day 78**: Create a FIFO (First-In-First-Out) buffer circuit. **(★★★★☆ Complexity: Very High)**
80. **Day 79**: Design a LIFO (Last-In-First-Out) stack buffer circuit. **(★★★★☆ Complexity: Very High)**

### Days 80-89: Sequential Circuits and FSMs

81. **Day 80**: Design a sequence detector for “101” pattern. **(★★★☆☆ Complexity: High)**
82. **Day 81**: Extend the sequence detector to recognize “1101”. **(★★★★☆ Complexity: Very High)**
83. **Day 82**: Create a finite state machine to control a vending machine. **(★★★★☆ Complexity: Very High)**
84. **Day 83**: Build a simple traffic light controller using FSM. **(★★★☆☆ Complexity: High)**
85. **Day 84**: Design a 3-state elevator controller FSM. **(★★★★☆ Complexity: Very High)**
86. **Day 85**: Construct a pedestrian crosswalk signal FSM. **(★★★☆☆ Complexity: High)**
87. **Day 86**: Create an FSM that counts up to a random number. **(★★★★☆ Complexity: Very High)**
88. **Day 87**: Build a 4-bit sequence generator using FSM. **(★★★★☆ Complexity: Very High)**
89. **Day 88**: Design a digital lock FSM (input PIN code). **(★★★★☆ Complexity: Very High)**
90. **Day 89**: Create a stopwatch using FSM and counters. **(★★★★★ Complexity: Expert)**

### Days 90-99: Final Advanced Projects

91. **Day 90**: Design a simple 4-function calculator (addition, subtraction, multiplication, division). **(★★★★★ Complexity: Expert)**
92. **Day 91**: Build a binary clock with hour, minute, and second displays. **(★★★★☆ Complexity: Very High)**
93. **Day 92**: Construct an 8-bit data encryption circuit. **(★★★★★ Complexity: Expert)**
94. **Day 93**: Design a 4-bit programmable timer. **(★★★★☆ Complexity: Very High)**
95. **Day 94**: Create a UART (Universal Asynchronous Receiver-Transmitter) circuit. **(★★★★★ Complexity: Expert)**
96. **Day 95**: Implement a digital thermometer simulation. **(★★★★☆ Complexity: Very High)**
97. **Day 96**: Design a 4-bit mini CPU (fetch, decode, execute). **(★★★★★ Complexity: Expert)**
98. **Day 97**: Build a programmable shift-and-add multiplier. **(★★★★★ Complexity: Expert)**
99. **Day 98**: Create a binary digital to analog converter (DAC) circuit. **(★★★★☆ Complexity: Very High)**
100.  **Day 99**: Final Project: Build a mini-processor with an ALU, control unit, and memory. **(★★★★★ Complexity: Expert)**
